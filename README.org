* keen4: Strongly-typed language targeting microcontrollers.

In general this is starting to turn into some the illegitimate child of
  Rust, Prolog, Idris?, and somehow Python with dashes (or maybe heaping
  spoonfuls?) of limitations generated by a potentially misguided desire
  to have entirely static memory management combined with provably
  finite recursion.

My aim isn't to create a language where the syntax is very tightly
  related to the final assembly, similar to what people _expect_ with C
  using -O0. In general, I'd like to keep the relationship non-mystical,
  but that doesn't mean it needs to be direct. I want concepts such as
  recursion, strong typing, pattern matching, type inference, and
  even perhaps logic programming without the fear of the overhead
  consuming too many cycles and with a boost to the ability to write
  correct software.

There will be no concept of a pointers in the C-style. There will be an
  `address` type, but it is effectively defined at compiler time and
  constant, cannot be mutated, and the address cannot be used in an
  expression as any reference to the variable will immediately
  dereference.  The concept of "taking the address of a variable" is
  non-existent. There will be some sort of C++-style reference, where
  the syntax handles it as a normal value, all without passing
  "addresses" around. It's more akin to move and borrow semantics/syntax
  in Rust.

My main concern isn't compiler speed. I want to do a lot of work
  up-front to ensure both correctness and that the least amount of work
  needs to be done at runtime.

I'm also perfectly happy enforcing rules that may make writing software
  more difficult at the gain of correctness, such as requiring:
  - recursion be finite (via a dependent type system) and utilize
    only tail-calls
  - stack depth checks

For my own sanity, I've tried to split the project into phases that
  should be individually doäble as follows.

** Phase I: Reäctivity
*** Phase I(a): Parsing Sections
*** Phase I(b): Type Assignment via Hindley–Milner
*** Phase I(c): Ensure reäctive parts are non-overlapping and exhustive
*** Phase I(d): Driver that will change variables and show current values
*** Phase I(e): Add an integer type with +, -, /, %, and *
                Should also be able to match on ranges [], (], [), and ()
                Range checking should also be exhustive
*** Phase I(f): Add `predicate` and `facts` sections

** Phase II: Input
*** Phase II(a): Add `init` and `loop` sections
*** Phase II(b): Serial Buffer
*** Phase II(c): `match` statement
*** Phase II(d): Pin input

** Phase III: Output
*** Phase III(a): Serial Buffer
*** Phase III(b): Pin output

** Phase IV: Arrays

** Phase V: Functions
*** Phase V(a): Declaring and calling functions
                Ensure only one return type
                Ensure no call cycles
*** Phase V(b): Introduce Peano Numbers and dependent types
*** Phase V(c): Match on array slices
*** Phase V(c): Allow finite tail-call recursion

** Phase VI: Compiling
*** Phase VI(a): Register and memory allocation
*** Phase VI(b): AST to ASM translation
*** Phase VI(c): Budgets
