# keen4

**__THIS IS A WORK IN PROGRESS. IT IS STILL BEING PLANNED. NO COMPILER EXISTS
YET__**

Experimental/Toy strongly-typed language targeting microcontrollers.

The `sample-xxx.k4` files are just where I'm trying to feel out
different syntaxes and ways of approaching problems. They may not be
indicitive of the final syntax.

Quite literally everything below this line may be contradictory, not
well thought out, or just plain nonsensical. This opening section
should, I'd hope, not become too incoherent or detached from your
present, but you've been warned.

In general this is starting to turn into some the illegitimate child of
Rust, Prolog, Idris?, and somehow Python with dashes (or maybe heaping
spoonfuls?) of limitations generated by a potentially misguided desire
to have entirely static memory management combined with provably finite
recursion.

My aim isn't to create a language where the syntax is very tightly
related to the final assembly, similar to what people _expect_ with C
using `-O0`. In general, I'd like to keep the relationship be
non-mystical, but that doesn't mean it needs to be direct. I want
concepts such as recursion, strong typing, pattern matching, type
inference, and even logic programming without the fear of the overhead
consuming too many cycles and with a boost to the ability to write
correct software.

# General Thoughts

My main target is the 8-bit AVR microcontrollers, but there shouldn't be
anything that prevents it from being used elsewhere.

There will be no concept of a pointers in the C-way. There will be an
`address` type, but it is effectively defined at compiler time and
constant, cannot be mutated, and the address cannot be used in an
expression as any reference to the variable will immediately
dereference. The concept of "taking the address of a variable" is
non-existent. There will be some sort of C++-style reference, where the
syntax handles it as a normal value, all without passing "addresses"
around. It's more akin to move and borrow semantics/syntax in Rust.

Everything is statically dispatched. Objects are not tagged in memory
with their type.

Tail Call Optimizations should be done when possible. (I'm still mulling
over what a good register assignment/storage method would be across
translation units, as to decrease the amount of register pushing and
popping that needs to be done, and how to do this effectively or what
needs to be present syntactically to help if it's difficult to do
automatically.)

My main concern isn't compiler speed. I want to do a lot of work
up-front to ensure both correctness and that the least amount of work
needs to be done on the processor.

## Basic Concepts

* No dynamic allocation - All allocation is done at compile-time
* Variables are not stored with run-time type information.
* Built-in Sum Types
    -  Optional
        + None
        + Some
* There exists a natural number type `Nat`. `Nat` types may only be used
  as dependent type parameters
    - Values
        + Z (zero)
    - Function
        + P (predecessor) (P(N) := n-1, P(1) := Z, P(Z) is not defined)
        + S (successor) (S(N) := n + 1, S(Z) := 1)
* Error handling should happen through Sum Types, no exception
  information
* `match`es
    - Exhaustive, but not exclusive, and match on a first-seen basis
    - May be over a tuple
    - Case of a tuple may contain an "anonymous" value, _ , matching all values
* No control structures other than `match`, `yield` and function calls
* All types have a static size
* `Swap` is a built-in, atomic function and performs an in-place swap
* Comparisons are done via the <=> operator and `match`
    - Values
        + EQ - Equal
        + LT - Less Than
        + GT - Greater Than
* Linear Type System
* RAII-style resource managment
    - Especially for periphials
* Raw Memory can be addressed by setting the address at compile or link time
    - Special, transparent type marker/wraper that forces behavior like `volatile` in C
    - As a LHS, the value will always be copied to the address
    - As a RHS, the value will always be copied from the address

## References

Variables that are the type of a record live a dual existance. They are
treated as references by most of the code, e.g. they are not copied
byte-by-byte when being passed to a function, but assignment and
swapping will work at the byte. For instance,

    record Point:
      uaint8 x
      uaint8 y

    a <- Point { x <- 1, y <- 2 }
    b <- Point { x <- 3, y <- 4 }

    # Does not create copies of a or b
    # Modifying a or b in `add` will cause a or b to be changed
    # out here too.
    add(a, b)

    # Copies the contents of b into the memory allocated for a
    a <- b

    # Does an in-place swap of the contents of a and b
    swap a b

## `require`

Libraries can be loaded via `require`.  If the target platform has no library,
then compilation will fail. Libraries can specify version requirements
at `require`-time.

Things like floating point, USART, I2C, Timers, DAC, PWM, PID/Math Accelerator,
&c support will require the library to be imported. For source libraries,
only require code/functions will be in the final output.

## Types of Types

There are two types of type: heap allocated and simple. Heap allocated types
cannot (in general) be represented in registers or on the stack. Heap allocated
types are passed-by-reference

Default, always available types are

* nibble
* byte
* boolean
* uaint8
* int16
* Array (fixed-size)
* LessThan{value}
* GreaterThan{value}

Note that floating point types are not always available.  Support would
require a `require floating_point` assertion.

## Overflow handling

Possibly done (partially) through the type system:

* `unsigned-overflow-allowed-int8` -> `uaint8`
* `unsigned-overflow-disallowed-int8` -> `udint8`
* `signed-overflow-allowed-int8` -> `saint8`
* `signed-overflow-disallowed-int8` -> `sdint8`

The `overflow-allowed` variants will not force a check for overflow
after the computation. `overflow-disallowed` will for a check, as in the
following example; note that assignment cannot be done in the match
clause because the result of the addition is not an integer. I would
really love to figure out a cleaner syntax for this.

    sdint8 x <- 0

    # Though, really, if you're just passing here, why?
    match x + 1:
      Ok(v):> x <- v
      Overflow(v):> pass
      Underflow(v):> pass

### No Dynamic Allocation

There is no way to dynamically allocate memory. All variables must be of
a known size at compile time and the compiler will figure out how to
best allocate memory then.

### Byte <=> Type Isomorphism

All types must map back to some size of bytes at compile time, which will be
allocated on the heap if more than 2 bytes.

    byte  = 1 byte
    uaint8  = 1 byte
    int16 = 2 bytes

    Packet := byte[6] = 6 bytes

    TwoPacket:
      Packet a
      Packet b
                 =  12 bytes # all allocations are sequential

    AB:
      uaint8  a
      int16 b
                 = 3 bytes

As such, the maximum amount of memory needed for any function call should
be able to be known at compile time.


Individual bytes can be set or manipulated via the `@` operator:

    ab <- AB (allocates (at compile time) 3 bytes in the heap)
    p@0 <- 0x01 # Sets the first byte to 0x01
    p@1 <- 0x02 # Sets the second byte to 0x02
    p@2 <- 0x03 # Sets the third byte to 0x03

    # ab.a == 1
    # ab.b == 515

## `LessThan` and `GreaterThan`

The value on the right of the `@` _must_ be less than the size of the object.
If a literal, this is checked at compile-time. If not, it must be of type
`LessThan{size}` (above, `LessThan{3}`) which can be a variable declared as
such, and when incremented or set some additional math is done to clean it
up. Example:

    x <- LessThan{sizeof{TwoPacket}}(0)
    x++

would roughly become something like, since it's an increment (or simple
addition of 2 `LessThan{x}` values):

    LDI  r16, 0
    INC  r16
    CPI  r16, 12
    BRCC after
    SUBI r16, 12
    after:

however, for an arbitrary set

    x <- LessThan{sizeof{TwoPacket}}(0)
    x <- UDR0

would become something like:

    LDI r16, 0
    LDS r16, UDR0
    loop:
    CPI  r16, $0C
    BRCC after
    SUBI r16, $0C
    BRCC loop
    after:


## Annotations and Budgets

A method can be annotated with notes to the compiler to error if a condition
isn't met, such as max memory used or max cycles to execute. (Something like
a "Language Server" or IDE in general should be able to extract the current
usage of the budget from the compiler as well.

    @budget cycles 6
    def hello():
      x <- LessThan{sizeof{TwoPacket}}(0)
      x++
      return x

will pass (using the entire budget (right now it's naÃ¯ve and will count `BRCC` as 2 cycles)), but

    @budget cycles 5
    def hello():
      x <- LessThan{sizeof{TwoPacket}}(0)
      x <- UDR0
      return x

will fail as it could require up to 129 cycles (if UDR0 was, say, 255)

## Transactions

Transactions are code where interrupts are turned off.

    def hello():
      transaction:
        x <- LessThan{sizeof{TwoPacket}}(0)
        return x

would give something like

    CLI
    LDI r16, $00
    SEI

## Tasks and Interrupts

### Tasks

Tasks are functions with two parts, `setup` and `body`. In `setup`, all
allocations must happen. All `setup`s for all tasks will be run before any
`body` is executed. The `body` of each task will be executed in a loop.
Execution of `body` will start at the beginning unless it had `yeild`ed.

### Interuppts

Interrupts are similar to tasks, but not executed in a loop, but when they
the interrupt happens.

## Table Definitions

Sometimes it makes sense to define a function by a table. Imagine if you will
a garage door. It opens when you hit the button, closes when you hit the
button, and opens when the sensor is triggered and it's closing.

    enum States := nibble:
      Open             := 0x0
      Opening          := 0x1
      Opening_Finished := 0x6
      Opening_Started  := 0x8
      Closed           := 0x2
      Closing          := 0x3
      Closing_Finished := 0x7
      Closing_Started  := 0x9
      Error            := 0x4
      Stopped          := 0x5

    enum Input := nibble:
      Button              := 0x0
      Obstical_Sensor     := 0x1
      Closed_Limit_Switch := 0x2
      Opened_Limit_Switch := 0x3
      No_Input            := 0x4

    table transition(States state, Input input) => States:
      | state            | input               | return           |
      | ----------       | --------            | ----------       |
      | Open             | Button              | Closing_Started  |
      | Open             | Obstical_Sensor     | Open             |
      | Open             | Closed_Limit_Switch | Error            |
      | Open             | Opened_Limit_Switch | Error            |
      | Open             | No_Input            | Open             |

      | Opening          | Button              | Stopped          |
      | Opening          | Obstical_Sensor     | Opening          |
      | Opening          | Closed_Limit_Switch | Error            |
      | Opening          | Opened_Limit_Switch | Opening_Finished |
      | Opening          | No_Input            | Opening          |

      | Opening_Finished | -                   | Open             |

      | Opening_Started  | -                   | Opening          |

      | Closed           | Button              | Opening_Started  |
      | Closed           | Obstical_Sensor     | Closed           |
      | Closed           | Closed_Limit_Switch | Error            |
      | Closed           | Opened_Limit_Switch | Error            |
      | Closed           | No_Input            | Closed           |

      | Closing          | Button              | Stopped          |
      | Closing          | Obstical_Sensor     | Stopped          |
      | Closing          | Closed_Limit_Switch | Closing_Finished |
      | Closing          | Opened_Limit_Switch | Error            |
      | Closing          | No_Input            | Closing          |

      | Closing_Finished | -                   | Closed           |

      | Closing_Started  | -                   | Closing          |

      | Error            | Button              | Opening          |
      | Error            | -                   | Error            |

      | Stopped          | Button              | Opening          |
      | Stopped          | Obstical_Sensor     | Stopped          |
      | Stopped          | No_Input            | Stopped          |
      | Stopped          | -                   | Error            |

## Match

Using the example above, we can look at how matching works.  Matches need to be
exhusive; the following will error:

    loop:
      input <- read_input()
      current_state <- transition(current_state, input)

      match current_state:
        case States.Opening_Started:
          start_motor_pulling_up()
          turn_light_on()
        case States.Opening_Finished:
          stop_motor()
          turn_light_off()

        case States.Closing_Started:
          start_motor_pulling_down()
          turn_light_on()
        case States.Closing_Finished:
          stop_motor()
          turn_light_off()

        case States.Error:
          blink_light()

However, we can add a default match:

    loop:
      input <- read_input()
      current_state <- transition(current_state, input)

      match current_state:
        case States.Opening_Started:
          start_motor_pulling_up()
          turn_light_on()
        case States.Opening_Finished:
          stop_motor()
          turn_light_off()

        case States.Closing_Started:
          start_motor_pulling_down()
          turn_light_on()
        case States.Closing_Finished:
          stop_motor()
          turn_light_off()

        case States.Error:
          blink_light()

        else:
          pass

## Macros

I'm still working out exactly how macros should behave and work. I think
I'm going to play around with Common Lisp, Rust, and maybe Nim macros.
Some initial thoughts can be seen in sample-002.

## Pattern Parameter Matching

### Array/Slice

`Array`s are what can be declared as variables. `Slice`s are what is used
for function parameters. Slice is explicetly calling out that this parameter
is an array, but not an array that you declared? I'm working on it.

The syntax for a Slice parameter can include that multiple items being
extracted from the Slice being passed in; one of the extracted parameters
may be prefixed with an @ symbol, symbolizing where the the rest of the
slice being passed in, that is the elements not being extracted.
For example: `[1,2,3,4]` passed into:

    [x,@rest]         => x=1, rest=[2,3,4]
    [@rest,x]         => x=4, rest=[1,2,3]
    [x,y,@rest]       => x=1, y=2, rest=[3,4]
    [x,@rest,y]       => x=1, y=4, rest=[2,3]
    [w,x,y,z,@rest]   => w=1, x=2, y=3, z=4, rest=[]
    [w,x,y,z,a,@rest] => compiler error

However, you cannot create a new slice from non-adjacent extracts. This is
allowed:

    func a(Slice{T} [a,b,@c]):
      a([a,b])
      a([b,@c])

but this is not:

    func a(Slice{T} [a,b,@c]):
      a([a,@c])

You'll need to have an array allocated and assigned to.

This may also be used in a `match`. However `match`es need to be exhustive,
for instance the following won't compile:

    func a(Slice{T} b):
      match b:
        [a,b,@c]:
          a([a,b])
          a([b,@c])

however, this will:

    func a(Slice{T} b):
      match b:
        [a,b,@c]:
          a([a,b])
          a([b,@c])
        [a, @c]:
          a([a])
          a([@c)
        [] -> pass

Some example usage:

    # So, what we're doing here for bubble short, is to take an array, extracted
    # the last element, partially sort the whole array, including the extracted
    # element. We then do this again, without the extracted element. If we
    # have no elements in the rest of the slice, then we terminate.
    def bubble_sort{T := Comparable, S := Slice{T}}(mut S array):
        match array:
          [@rest, x]:
            bubble_partial_sort([rest, x])
            bubble_sort(rest)
          [] -> pass

    # This function partially sort the passed in slice by extracting the last
    # two elements, swapping them if nessecary. Swap happens in-place, so
    # we can then partially sort the remainer of the slice by passing in
    # the rest prepended to the first extracted value. (Values can only be
    # concatented in the order extracted: rest;y is a compiler error below.
    def bubble_partial_sort{T := Comparable, S := Slice{T}}(mut S array):
      match array:
        [@rest, x, y]:
          if x > y:
            swap x y
          bubble_partial_sort([rest,x])
        [@rest, x] -> pass
        [] -> pass

    # Since slice extracts act like references, assigning to them
    # will change the value in the array.
    def void double{T := Addable, A := Slice<size_a>{T}, B := Slice<size_b>{T}; size_b >= size_a}(A a, mut B b):
      match a, b:
        [x, @xs], [y, @ys]:
          y <- x + x
          double(xs, ys)
        [], [y, @ys] -> pass
        [], [] -> pass

    # Reduce the array by extracting the first element, adding it to the
    # carry. If there is nothing left to recurse on, we return the
    # carry.
    def T sum{T := Addable, S := Slice{T}}(S array, T carry):
      return match array:
        [x,@xs] -> return sum(xs, carry + x)
        [] -> return carry

Since these can be tail-call optimized, the compiler will be able to
produce decent code for this without requiring lots of stack space.

Part of the rationale for this is avoiding a looping construct. I'm just
not a fan of loops and find they're easy to get wrong. If you don't use
array indecies, you can't have off-by-one errors.

### Records

A similar thing can be done for records. A record can be followed by an
expression that will extract fields (and potentially not all fields) into
function-local variables. I'm still debating this one, but I think it's
neat.

    record Vector:
      uaint8 x
      uaint8 y

    func add(Vector {x x1, y y1}, Vector {x x2, y y2}) => Vector:
      return Vector { x <- x1 + x2, y <- y1 + y2 }

## Traits

Traits are a way of defining composable functionality. `record`s are
simple structures in memory and contain no function definitions on them.
Traits allow one to define functionality on `record`s, similar to how
it's done in rust. This is not inhereitence in the normal
object-oriented way -- there are no parents or base classes; the
closest description is that traits are similar to interfaces, if
intefaces can't have a parent.

To define a trait, you list the methods it has, and then you can implement
if for a type.

    record Point:
      uaint8 x
      uaint8 y

    trait Addable{S,T}:
      op +(S a, T b)
      op -(S a, T b)

    trait Comparable{T}:
      op <(T a, T b)

    impl Addable{S := Point, T := Point}:
      op +(S a, T b):
        return Point {x <- a.x + b.x, y <- a.y + b.y}
      op -(S a, T b):
        return Point {x <- a.x - b.x, y <- a.y - b.y}

    # This isn't the best way to compare points...but it's a way?
    impl Comparable{Point}:
      op <(Point a, Point b):
        return a.x < b.x || a.y < b.y

To constrain traits on a function parameter, use `;`:

    func do_stuff{T := Addable;Comparable}(T a, T b):
      pass

notice how the constraints are defined before the parameter list, not
inside.

## Physical Unit Types

Arbitrary units can be tacked onto types. Type conversions can be
defined. Only integral conversions are defined by default. (Division
isn't defined by default. A library should be importated that does
floating or fixed point math. Such a library should make precisions
explicit. I'd love to be able to track accuracy in calculations,
but...that's for another day.) Types may be combined via `*` and `/` to
produce derived types.

    uaint8!sec duration <- 10
    uaint8!ft/sec speed <- 1

    def report_speed(uaint8!m/h speed):> pass

    # compile error
    report_speed(freq)

    uaint8!ft distance <- speed * duration

    # compiler error
    uaint8!ft distance2 <- duration


## Variant/Sum Types

Fairly standard Sum type and matching.

    enum ThingToDo:
      Nothing
      Blink(times, uaint8!seconds single_duration, LessThan{100}!percent duty_cycle)
      Beep(uaint8!kHz frequency, uaint8!seconds duration)

    match queue.dequeue:
      Nothing:> pass
      Blink(times, single_duration, duty_cycle):> pass
      Beep(frequency, duty_cycle)

## Dependent Types

Dependent Types are when a type is specified by some value. So below,
the `TreeNode` is dependent on the value of `n`. (Note, I'm begining to
think that the dependt part and the parametric part should be seperated
syntactially.) By using Peano numbers as the dependent value, recursion
can be done in a way where it can be proven to end. (It should also be
done in a way where tail-calls are always done, but that's a different
story for a another section.)

    struct TreeNode{N n, type T}:
      TreeNode{P(n), T} left
      TreeNode{P(n), T} right
      Optional{T} node_value

    struct TreeNode{Z, T}:
      Optional{T} node_value

    func find{n}(TreeNode{n, T} tree, T value_to_find) -> Boolean:
      return match tree.node_value:
        case Empty -> false
        case Val(v):
          match (n, v <=> value_to_find):
            case (_, EQ) -> true
            case (Z,  _) -> false
            case (_, LT) -> find(tree.left, value_to_find)
            case (_, GT) -> find(tree.right, value_to_find)


# Constraints / Logic Programming

(Taken from sample-013. Syntax very subject to change.)

(The biggest thing I need to figure out is how I want to allow
unification to potentially set values? For instance, below, if I change
the occupancy of `T3`, the settings for `S5` and `S6` should change to
`Stop`. What's a clean way to do this at all assignments of `T3` without
having to know about the structure of what's being represented at every
assignment.)

    # W                                    E
    #            <S1   T4   >S2
    #            --------------
    #           /              \
    #      >S6 / <S3        >S4 \  <S5
    #   ----------------------------------
    #    T1  W1        T3       W2   T2


    constraint rules:
      Signal_For_Track_Direction(Track, Direction, Signal) := True

      Switch_Track(Track_Union, Switch, Position, Track_Other) := True

      Track_Connection(Direction1, Track1, Track2, Direction2) := True -> Track_Connection(Direction2, Track2, Track1, Direction1)

      Track_Occupied(T) := T != Empty

      Switch_Straight(W) := W = 'Straight
      Switch_Diverted(W) := W = 'Diverted

      Track_Opposing_Switch(W) :=
            Switch_Track(TU, W, 'Diverted, TD)
          & Switch_'Straight(W)
          & Track_Connection(DU, TU, TD, DD)
          & Signal_For_Track_Direction(TD, DD, S)
          ->
          S = 'Stop

      Next_Track_Occupied(T) :=
            Track_Connection(Dt, T, To, Do)
          & Track_Occupied(To)
          & Signal_For_Track_Direction(T, Dt, S)
          ->
          S = 'Stop

    constraints:
      Signal_For_Track_Direction(T4, 'West, S1)
      Signal_For_Track_Direction(T4, 'East, S2)

      Signal_For_Track_Direction(T3, 'West, S3)
      Signal_For_Track_Direction(T3, 'East, S4)

      Signal_For_Track_Direction(T1, 'East, S6)

      Signal_For_Track_Direction(T2, 'West, S5)

      Switch_Track(T1, W1, 'Straight, T3)
      Switch_Track(T1, W1, 'Diverted, T4)

      Switch_Track(T2, W2, 'Straight, T3)
      Switch_Track(T2, W2, 'Diverted, T4)

      Track_Connection('West, T3, T1, 'East)
      Track_Connection('West, T4, T1, 'East)

      Track_Connection('East, T3, T2, 'West)
      Track_Connection('East, T4, T2, 'West)

So, this is what I'm having trouble with. Since in the above a signal is
part of the consequence, and I'd like it to be able to have it set when
appropriate.

    match unify T3 <- Easbound:
      Ok:>pass
      Conflict(rule):> pass

Opens up some other questions to, like for a value in the constraints is
update, should it require special syntax to signify that a lot more is
about to happen than assignment? or to specify that I want a check only
and no updates?

    match verify T3 <- Eastbound:
      Ok:> pass
      Conflict(rule):> pass

Now, this could be a very slow process, but in general, the compiler
will attemp to simplify the unification process at compiler time.

`Track_Opposing_Switch` would compile to the following function based on
a lookup table for the other parameters.

We _could_ hash out all the values of the enum for P and turn this
into an equality, but....that's a lot of work? maybe later?

So what I mean, the first term is really !(W != P), which is equiv to
W = P. We could set P in the table to be the opposite state (P') and just
keep (W = P') -> S = 'Stop (!(W = P') || (S = 'Stop)) but, meh.

    Track_Opposing_Switch(W1) := (W1 = 'Diverted) || ((S1 = 'Stop) || assign(S1, 'Stop))
    Track_Opposing_Switch(W1) := (W1 = 'Straight) || ((S3 = 'Stop) || assign(S3, 'Stop))
    Track_Opposing_Switch(W2) := (W2 = 'Diverted) || ((S2 = 'Stop) || assign(S2, 'Stop))
    Track_Opposing_Switch(W2) := (W2 = 'Straight) || ((S4 = 'Stop) || assign(S4, 'Stop))

In the end, when W1 or W2 is set, it'll be checked against only 2 of
those constraints, and the whole process of unification is largely
skipped.

/* vim: set ts=2 tw=72 : */
