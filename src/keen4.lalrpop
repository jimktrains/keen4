use crate::ast::nodes::{Fact, Term, Var, Predicate, ExprSide, Expr, Operator, PFact, Program};

grammar;

pub Fact : Fact<'input> = <name:r"[a-z][A-Za-z0-9_]*"> "(" <terms:List<Term>> ")" 
  => Fact{name:name, terms:terms};

pub Predicate : Predicate<'input> = <name:r"[A-Z][A-Za-z0-9_]*"> "(" <vars:List<Var>> ")"
  => Predicate{name:name, vars:vars};

pub PFact : PFact<'input> = <name:r"[a-z][A-Za-z0-9_]*"> "(" <vars:List<Var>> ")" 
  => PFact{name:name, vars:vars};

pub ExprSide : ExprSide<'input> = {
  <p:Predicate> => ExprSide::Predicate(p),
  <f:PFact>     => ExprSide::PFact(f),
};

pub OrExpr : Expr<'input> = {
  <lhs:ExprSide> "|" <rhs:ExprSide> => Expr{lhs:Box::new(lhs), rhs:Box::new(rhs), op:Operator::Or}, 
  <lhs:ExprSide> "|" <rhs:OrExpr> => Expr{lhs:Box::new(lhs), rhs:Box::new(ExprSide::Expr(rhs)), op:Operator::Or}, 
};

pub AndExpr : Expr<'input> = {
  <lhs:ExprSide> "&" <rhs:ExprSide> => Expr{lhs:Box::new(lhs), rhs:Box::new(rhs), op:Operator::And}, 
  <lhs:ExprSide> "&" <rhs:AndExpr> => Expr{lhs:Box::new(lhs), rhs:Box::new(ExprSide::Expr(rhs)), op:Operator::And}, 
};

pub Expr : ExprSide<'input> = {
  <e:OrExpr>   => ExprSide::Expr(e),
  <e:AndExpr>  => ExprSide::Expr(e),
  <e:ExprSide> => e,
};


Term : Term<'input> = <name:r"[A-Z][A-Za-z0-9_]*"> => Term(<>);
Var : Var<'input> = <name:r"\$[A-Z][A-Za-z0-9_]*"> => Var(<>);

List<T> : Vec<T> = {
  <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
