#################################################################
# System Definitions that would be part of the standard library
#################################################################

class InputPin<PinNum>:
  Low
  High

cast InputPin<PinNum> as boolean:
  return match self:
    Low: False
    High: True

enum OutputPin<PinNum>:
  Low
  High

#################################################################
# Global Definitions used across the whole project.
#################################################################

# Being ordered is special. When doing a comparison, any later definition
# can subsume an earlier one as a logically set value.
# For instance, if there are consequences of Stop(S) and Approach(S),
# then setting S = Stop will satisfy the Approach(S) constraint as well.
orderedenum SignalAspect<Pin1:OutputPin, Pin2:OutputPin>:
  Clear
  Approach
  Stop
  Unknown

enum OccupancyDetector<WestDetector:InputPin, EastDetector:InputPin>:
  Empty
  Eastbound
  Westbound
  Unknown

# This defines a table. The first row are the input and output variables.
# Input and output are seperated by a double pipe.
# Variables are seperated by a pipe.
# Evaluation happens in order from top to bottom.
# _ in an input is a wildcard.
# _ in an output means the value remains unchanged.
# All cases must be exhusted.
def OccupancyDetector<WestDetector, EastDetector>::read():
  || self      | WestDetector | EastDetector || self      |
  |+-----------+--------------+--------------++-----------+
  || Empty     | High         | Low          || Eastbound |
  || Empty     | Low          | High         || Westbound |
  || Empty     | High         | High         || Unknown   |
  || _         | Low          | Low          || Empty     |
  || Eastbound | _            | _            || _         |
  || Eastbound | _            | _            || _         |
  || Unknown   | _            | _            || _         |

# This is roughly equivlient to the above
def OccupancyDetector<WestDetector, EastDetector>::read2():
  # In a match case, _ is a wildcard.
  # All cases of a match must be exhustive.
  self <- match self, WestDetector, EastDetector:
    Empty    , High, Low  :: Eastbound
    Empty    , Low , High :: Westbound
    Empty    , High, High :: Unknown
    _        , Low , Low  :: Empty
    Eastbound, _   , _    :: self
    Westbound, _   , _    :: self
    Unknown  , _   , _    :: self

# This is roughly equivlient to the above, but written as a DOT
# thenode is both an input and an output
# All cases must be exhustivly matched.
# Will be able to pull in from a file.
# The idea is for (complex) state machines can be layed out in a more
# natural way.
def OccupancyDetector<WestDetector, EastDetector>::read2():
  digraph g {
    thenode=self;
    label="WestDetector,EastDetector";
    
    Empty -> Eastbound [label="High,Low"];
    Empty -> Westbound [label="Low,High"];
    Empty -> Unknown [label="High,High"];
    Empty -> Empty [label="Low,Low"];

    Eastbound -> Empty [label="Low,Low"];
    Eastbound -> Eastbound [label="_,_"];

    Westbound -> Empty [label="Low,Low"];
    Westbound -> Westbound [label="_,_"];

    Unknown -> Empty [label="Low,Low"];
    Unknown -> Unknown [label="_,_"];
  }

# Statements are what will later be used to define facts.
# the spaceship operator (<=>) can be used to define a reflexive
# relationship.
statements:
  connected(A:OccupancyDetector, B:OccupancyDetector) <=> connected(B, A)
  signal_protects(S:SignalAspect, A:OccupancyDetector)

# Predicates are defined as single logical expressions.
# For the moment only the =, <, <=, >=, >, &, |, and in operators are supported
predicates:
  occupied(A:OccupancyDetector) := A in (Eastbound, Westbound, Unknown)
  empty(A:OccupancyDetector) := A in (Empty)

# The consequence of a constraint will be automatically set to a value
# that will fulfill all constraints. If a value in a consequence is only
# ever compared/set in a consequence and the value is an orderedenum, then the
# assignment should never be able to fail, because there should always be a 
# greatest value that can be assigned that'll satisfy all constraints.
#
# For instance, below, the signal aspect will be resolved, and should always
# be able to be resolved.
#
# Otherwise, the constraint may fail and any assignment of any variables
# must be inside a match and able to catch the failed assignment.
#
# A constraint may have no consequences, in such a case no values will
# be changed, only the assignment can fail or not.
#
# For the moment, only predicates, statements, &, |, and => are supported.
# N.B. The values of an enum may be used as predicates to test for equality
#      or for an orderedenum to test for compatibility.
constraints:
  occupied(A) & signal_protects(S, A) => Stop(S)
  connected(A, B) & empty(A) & occupied(B) & signal_protects(S, A) => Approach(S)
  connected(A, B) & empty(A) & empty(B) & signal_protects(S, A) => Clear(S)

#################################################################
# This would be part of the main program for this block, a.k.a. 
# this section of track.
#################################################################

# Track Sections
#    A      B      C
# ------|------|------
# S      S      S
# Signal Locations

SignalAspect<OutputPin<1>,OutputPin<2>> SA
SignalAspect<OutputPin<3>,OutputPin<4>> SB
SignalAspect<OutputPin<5>,OutputPin<6>> SC

readonly OccupancyDetector<InputPin<7>, InputPin<8>>  A
readonly OccupancyDetector<InputPin<9>, InputPin<10>> B
readonly OccupancyDetector<InputPin<10>,InputPin<11>> C

facts:
  connected(A, B)
  connected(B, C)
  signal_protects(SA, A)
  signal_protects(SB, B)
  signal_protects(SC, C)

main:
  A.read()
  B.read()
  C.read()
